---
layout: post
title:  "Fresh Crypto"
date:   2020-08-25 18:15:30 +0000
tags: math crypto ms-dos
---
{% include mathjax.html %}

# Fresh Crypto 
* Table of Contents
{:toc}

## Intro
Description of project - decrypting QText documents the passcode to which has been lost
Short blog post describing the process of reversing and attacking the fairly weak encryption mechanism.
A lot of the tools (Unpackers, IDA Free) and knowledge used had barely survived to this day.

## Getting started - QText
Luckily, we had access to working QText binaries and the [DOSBOX][dosbox] emulator.

TODO: Screenshots of software, early conclusions on form of crypto

* Passcode is short - 4 characters and limited to uppercase characters and numbers - very small keyspace
* Header is added to encrypted files - same passcode == same header - is it the encryption key?
* 16 byte key (TODO - add vimdiff of hexdump of two file headers) is included in header - no actual secret
* Per line encryption, per column values (show line of `'aaaa'`s encrypted, as well as line of `'a a '`s

The key may be included in the file, but we don't know the encryption mechanism. 
We could try and reverse it, but brute-forcing is feasible and simpler in this case - if we have a fast way to test the passcodes. 
Assuming (quite safely) that the 16 byte "key" is derived from the passcode - we can try to reverse engineer the key derivation algorithm - which we first confirmed was not any well known hash function.

## Reversing MS-DOS binaries
MS-DOS era binaries - not quite PE, but does start with MZ
TODO Reminder about flat memory space - 16 bits, segmentation

### PKZip
The `file` utility recognizes our binary as a [PKZip][pkzip-wiki] packed SFX - self extracting executable.
TODO - screenshot of file output

PKWare is responsible for the popularity of the ZIP file format as we know it today, 
but it was also responsible for a widely used executable packer in the MS-DOS age.

There isn't any readily available information about PKZip - presumably it utilized the same compression algorithm as the normal zip utility,
but we were struggling to find a tool that would properly unpack the SFX to a plain executable.

Having failed to find additional information about this packer, and wanting to avoid reverse engineering the unpacker stub - 
We tried to use the DOSBOX debuggers CPU LOG feature to step past the unpacker code, sometime after the original entry point - and then extract the code from memory.

While this did work, it only accounted for a small part of the code - the executable was TODO in size and we could only see one segment of code executing at that time.

Recalling older days of reversing crackmes (though not as old as this program) reminded me that there used to be a host of generic unpacker tools, the working of which 
were often mysterious - but generally speaking they did the job.
Eventually we found the [following ssowkolow blog post][ssowkolow] which guided me to the the legendary reverse engineering relic - [exetools][exetools].

The unpacker page had a huge amount of unpackers, we assume a lot of them would have done the job - as PKZip was fairly common. 
We first tried the one called `PKUNLITE`, and when that didn't work (but looked promising) - we found success with `DISLITE v1.15`.

TODO - screenshots of both tools running

### `int 3f` - MS-DOS Overlays
Loading the binary in IDA Free 5.0 (which luckily is still in distribution - hosted at the ScummVM website) showed that the executable utilized dynamic overlay linking - likely Turbo Pascal overlays.

Overlays were the solution to the limited 16 bit memory space. 

The overlay mechanism was essentially an implementation of page swapping in user-space:
The executable contained root segments of non-movable memory, and was accompanied by an .ovr file which contained additional code (in this case, a LOT of additional code).

The root code (which originates from the .exe file) was always mapped into memory, while segments of the overlay were mapped into memory selectively and swapped on-demand.

Calls between overlays (and the root segment) occured through a jump table, if the overlay was already mapped into memory, the jump table stubs were "linked" to its current location in memory.

Otherwise, it led to (in this case) an [`int 3f`][dos4gw] instruction, and alongside it - the overlay metadata.

The overlay metadata contained - among other things - the file offset of the relevant code segment.

The interrupt handler would then map the relevant overlay into memory, in place of another overlay, and fix up the stubs, before resuming execution.

TODO - screenshot of overlay metadata and screen shot of linked jump 

IDA does an excellent job in flattening and statically linking the stubs so we can reverse engineer the program in its entirety.

However this presented a challenge for us in dynamically debugging the code, since while the root segment were always loaded into the same memory area, the overlays would change location very often, making it impossible for us to place breakpoints properly.

Dredging up information about the Turbo Pascal overlay system was difficult, and the DOSBOX debugger did not explicitly support stepping out of the interrupt.

It's likely that we could have reverse engineering the interrupt handler and found a place to break in right before resuming program execution in the newly loaded overlay,
but we eventually opted for a simpler solution - finding an overlay-to-root call that we could break on and then step out into the newly loaded overlay.

This is slightly arduous but for the fairly short task at hand it would work, and we had ample overlay-to-root calls to break on since the root segment hosted a lot of
Turbo Pascal standard functions.

TODO - screenshot of overlay function calling root segment function

## Key expansion function
### Tracing through passcode flow
Finding the key expansion function took some reversing and a lot of tracing.
Our initial idea was perform hot spot analysis by using DOSBOX's CPU log command to trace execution while repeatedly failing the passcode check on a locked document.
TODO - add screenshot of failed passcode check

Eventually we went for a more direct approach and simply placed a breakpoint on the `int 21` interrupt handler to catch open and read calls
TODO - add debugger picture, correct int 21 params

We traced through an open on the document path and a read of 0x1d bytes - which is the exact size of the header we saw in locked documents.
Continuing with dynamic debugging, we pinpointed a function that takes the entered passcode string and the 0x1d header as parameters.

Digging in, we see how the the passcode is passed into an internal function, and the result is compared to the header.

TODO - add IDA screen shot of main function, and of pascal string compare call

Presumably, the function at TODO performs key expansion.

### Key derivation function
The passcode is first passed through a permutation function which iteratively increments each byte of the passcode by the sum of all bytes in the string.
Before proceeding to the byte in the next position, a certain predicate is tested by using the value of the resulting byte as an index into a static bitmap - where each bit represents whether or not
that byte value is valid (1) or not (0). Similar to [CFG][cfg-wiki]!

If the value is invalid - it is incremented by 0x22 - which in the case of our immutable bitmap - is always enough to push it into the valid value range.
TODO - screen shot of bitmap

{::options parse_block_html="true" /}
<figure>
{% highlight python %}
 24 # Taken from binary
 25 BITMAP = b"\xff\xff\xff\xff\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80"
...
 28 def is_valid_char(c):
 29     # Can be simplified as 0x20 < c < 0x100
 30     assert type(c) is int
 31     assert c <= 0xFF
 32     upper_idx = c >> 3  # upper 5 bits
 33     lower_idx = c & 0b111  # Lower 3 bits
 34     return not bool((BITMAP[upper_idx] >> lower_idx) & 1)
{% endhighlight %}
<center>
<figcaption><i>Excerpt from qtext_cracker.py - the predicate recreated in python</i></figcaption>
</center>
</figure>
{::options parse_block_html="false" /}
Concretely, this can be represented by simply checking if $$0x20 \lt value \lt 0x100$$  ðŸ¤·

The permutation function $$P(x)$$ is simple - it iteratively increments each byte by the sum of the entire string at that point:
{::options parse_block_html="true" /}
<figure>
{% highlight python %}
 37 def key_transform(input_key, modifier=0x22):
 38     assert type(input_key) is bytearray
 39     key = bytearray(input_key)  # copy
 40     for i in range(len(key)):
 41         for j in range(len(key)):
 42             key[i] = (key[i] + key[j]) & 0xFF
 43         while not is_valid_char(key[i]):
 44             key[i] = (key[i] + modifier) & 0xFF
 45     return key
{% endhighlight %}
<center>
<figcaption><i>Excerpt from qtext_cracker.py - the permutation function recreated in python</i></figcaption>
</center>
</figure>
{::options parse_block_html="false" /}

After that, the string is concatenated to itself (in place) 3 times, and passed through the permutation function again.
The result of this is indeed the key as it appears in the header.

Thus the key derivation function $$K(\text{passcode})$$ is:

$$K(\text{passcode}) = P(P(\text{passcode}) | P(\text{passcode}) | P(\text{passcode}) | P(\text{passcode}))$$

Now we can brute-force the passcode which has a very small input space very quickly.
However, with our new-found knowledge of the key derivation function, we can try to reverse it for an even quicker solution.

## Reversing the key derivation
Let's first examine a simple case - the result of permutating a simple two character string - '00':
{::options parse_block_html="true" /}
<style>
/*
 *  Start with the steps being hidden
 */
#Step1 {
    display: block;
}
#Step2, #Step3, #Step4, #Step5 {
  display: none;
}
</style>

<script type="text/javascript">
//
//  Use a closure to hide the local variable
//
(function () {
  var n = 1;

  //
  //  Make the current step be visible, and increment the step.
  //  If it is the last step, disable the step button.
  //  Once a step is taken, the reset button is made available.
  //
  window.ShowStep = function () {
    document.getElementById("Step"+n).style.display = "none"; n++;
    document.getElementById("Step"+n).style.display = "block"
    if (n == 5) {
        document.getElementById("step").disabled = true
    }
    document.getElementById("reset").disabled = false;
  }

  //
  //  Enable the step button and disable the reset button.
  //  Hide the steps.
  //
  window.ResetSteps = function () {
    document.getElementById("step").disabled = false;
    document.getElementById("reset").disabled = true;
    var i = 1, step; n = 1;
    while (step = document.getElementById("Step"+i)) {step.style.display = "none"; i++}
    document.getElementById("Step1").style.display = "block"
  }
})();
</script>
<script type="text/x-mathjax-config">
  //
  //  Make displayed equations be aligned left and indented
  //
  //MathJax.Hub.Config({
  //  displayAlign: "center",
  //});
  //
  //  Enable the step button after the equation is typeset
  //
  MathJax.Hub.Queue(function () {
    document.getElementById("step").disabled = false;
  });
</script>
<div style="overflow-x: scroll">
<div id="math" align=center>
$$ 
\cssId{Step1}
{
    \begin{align}
    \begin{array}{cc}
        \boxed
        {
            \begin{array}{l|rr}
                j: &     0 & \color{silver}1 \\
                i: &     0 & \color{silver}1 
            \end{array} 
        }
        & & &
        \begin{array}{rr}
            & v[j]: & \phantom{\mathrm{30}} & \mathrm{30} & \color{silver}{\mathrm{30}} \\
            +& v[i]: & \phantom{\mathrm{30}} & \mathrm{30} & \color{silver}{\mathrm{30}} \\
            \hline
            & & \phantom{\mathrm{30}} & \mathrm{\phantom{\color{red}{1}}60} & \color{silver}{\mathrm{\phantom{1}30}}
        \end{array} 
    \end{array} 
    \end{align}
}
\cssId{Step2}
{
    \begin{align}
    \begin{array}{cc}
        \boxed
        {
            \begin{array}{l|rr}
                j: &     \color{silver}0 & 1 \\
                i: &     0 & \color{silver}1 
            \end{array} 
        }
        & & &
        \begin{array}{rr}
            & v[j]: & \color{silver}{\mathrm{60}} & \mathrm{30} \\
            +& v[i]: & \phantom{\mathrm{30}} & \mathrm{60} & \color{silver}{\mathrm{30}} \\
            \hline
            & & \phantom{\mathrm{30}} & \mathrm{\phantom{\color{red}{1}}90} & \color{silver}{\mathrm{\phantom{1}30}}
        \end{array} 
    \end{array} 
    \end{align}
}
\cssId{Step3}
{
    \begin{align}
    \begin{array}{cc}
        \boxed
        {
            \begin{array}{l|rr}
                j: &     0 & \color{silver}1 \\
                i: &     \color{silver}0 & 1 
            \end{array} 
        }
        & & &
        \begin{array}{rr}
            & v[j]: & \phantom{\mathrm{30}} & \mathrm{90} & \color{silver}{\mathrm{30}} \\
            +& v[i]: & \color{silver}{\mathrm{90}} & \mathrm{30} & \phantom{\mathrm{30}} \\
            \hline
            & & \color{silver}{\mathrm{90}} & \mathrm{\color{red}{1}c0} & \phantom{\color{silver}{\mathrm{\phantom{1}30}}}
        \end{array} 
    \end{array} 
    \end{align}
}
\cssId{Step4}
{
    \begin{align}
    \begin{array}{cc}
        \boxed
        {
            \begin{array}{l|rr}
                j: &     \color{silver}0 & 1 \\
                i: &     \color{silver}0 & 1 
            \end{array} 
        }
        & & &
        \begin{array}{rr}
            & v[j]: & & \color{silver}{\mathrm{90}} & \mathrm{c0} \\
            +& v[i]: & \phantom{\mathrm{30}} & \color{silver}{\mathrm{90}} & \mathrm{c0} \\
            \hline
            & & \phantom{\mathrm{30}} & \color{silver}{\mathrm{\phantom{1}90}} & \mathrm{\color{red}{1}80}
        \end{array} 
    \end{array} 
    \end{align}
}
\cssId{Step5}
{
    \begin{align}
    \begin{array}{cc}
        \boxed
        {
            \begin{array}{l|rr}
                j: &     \color{silver}0 & 1 \\
                i: &     \color{silver}0 & 1 
            \end{array} 
        }
        & & &
        \begin{array}{rr}
            & v[j]: & & \color{silver}{\mathrm{90}} & \mathrm{c0} \\
            +& v[i]: & \phantom{\mathrm{30}} & \color{silver}{\mathrm{90}} & \mathrm{c0} \\
            \hline
            & P(\text{'00'}) & = & \color{green}{\mathrm{\phantom{1}90}} & \color{green}{\mathrm{\phantom{1}80}}
        \end{array} 
    \end{array} 
    \end{align}
}
$$

<input type="button" onclick="ShowStep()" value="Show Next Step" id="step" disabled="true" />
<input type="button" onclick="ResetSteps()" value="Reset" id="reset" disabled="true" />
</div>
</div>
{::options parse_block_html="false" /}

The permutation process for a string of length 2 can also be described as:

{::options parse_block_html="true" /}
<div align=center style="overflow-x: scroll">
$$
\begin{array}{l|ll}
        \text{input bytes} &a_1, &a_2 \\
        \text{step 1} &a_1 + a_1 + a_2, &a_2  \\
        \text{step 2} &a_1 + a_1 + a_2, &a_2 + (a_1 + a_1 + a_2) + (a_2 + (a_1 + a_1 + a_2)) \\
        P(\text{input bytes})&\color{olive}{2a_1 + a_2}, &2(a_2 + (\color{olive}{2a_1 + a_2}) \\
        P(\text{'00'})&\mathrm{\color{olive}{0x90}}, &\mathrm{0x80}
\end{array}
$$
</div>
{::options parse_block_html="false" /}

The permutation only involves combinations of our input values - so it's linear, but it isn't strictly linear - we lose the carry bit in any operation that overflows $$0xFF$$. 

Let's say we want to reverse the permutation - starting from the last byte.
We know that $$\color{olive}{2a_1 + a_2}$$ evaluted to $$\mathrm{\color{olive}{0x90}}$$, so we can substitute for it:

{::options parse_block_html="true" /}
<div align=center style="overflow-x: scroll">
$$
\begin{array}{ll}
2(a_2 + (\color{olive}{2a_1 + a_2}) & \equiv \mathrm{0x80} \pmod{0x100} \\
2(a_2 + (\color{olive}{0x90}) & \equiv \mathrm{0x80} \pmod{0x100}
\end{array}
$$
</div>
{::options parse_block_html="false" /}

But now, since we have to divide by 2 (which is not invertible in this field) - there are two possible solutions:

{::options parse_block_html="true" /}
<div style="overflow-x: scroll">
$$
\begin{array}{l}
\begin{align}
    &a_2 + \color{olive}{0x90} \equiv \mathrm{0x40} \pmod{0x100} \tag{case 1} \\
    &a_2 + \color{olive}{0x90} \equiv \mathrm{0xc0} \pmod{0x100} \tag{case 2} \\
    \\
    &a_2 = \color{red}{0xb0} \tag{case 1} \\
    &a_2 = \color{green}{0x30} \tag{case 2}
\end{align}
\end{array}
$$
</div>
{::options parse_block_html="false" /}

We happen to know that the correct value here is 0x30, but generally speaking when trying to invert the permutation function we'll have to superimpose both results.
Simply put - at each step of the decomposition process, we "split" into two branches - one for each result.

In addition, for a certain range of values, another split occurs - 
at the end of each byte permutation, if the byte falls into a certain set of values ($$0x20 \lt b \lt 0x100$$) is is incremented by $$0x22$$.

That means that if the byte we're currently looking at is between $$0x20+0x22 \equiv 0x42$$ and $$0x100 + 0x22 \equiv 0x22$$, we need to consider a case where it may have been
incremented to that value, and not arrived at naturally.

Thankfully, the correction accounts for the entire span of the "forbidden" values, so it can only occur once - and thus only accounts for one additional branch.

Summarizing - at each stage of the key decomposition we branch out between once and twice. 
Below is an implementation of the decomposition algorithm using recursion:
<figure>
{% highlight python %}
 48 def recursive_decomposition(input_key, decomposed_part=None, stop_at=4):
 49     assert type(input_key) is bytearray
 50     key = bytearray(input_key)  # copy
 51     if decomposed_part is None:
 52         decomposed_part = bytearray()
 53 
 54     if len(key) == 0:
 55         # Stopping condition
 56         return [
 57             decomposed_part,
 58         ]
 59 
 60     if stop_at is not None:
 61         if len(decomposed_part) >= stop_at:
 62             return [
 63                 decomposed_part,
 64             ]
 65 
 66     results = []
 67     value = key.pop()
 68     if not is_valid_char((value - 0x22) % 0x100):
 69         # We have an additional case to process
 70         new_key = bytearray(key)  # copy
 71         new_key.append((value - 0x22) % 0x100)
 72         # Where to save this?
 73         results.extend(recursive_decomposition(new_key, decomposed_part, stop_at))
 74 
 75     value = (value - sum(decomposed_part)) % 0x100
 76     # Subtract trailing (decomposed) characters
 77     # Compute two candidates
 78     candidate_1 = ((value // 2) - sum(key)) % 0x100
 79     candidate_2 = (((0x100 + value) // 2) - sum(key)) % 0x100
 80     new_decomposed_left = bytearray([candidate_1,]) + decomposed_part
 81     new_decomposed_right = bytearray([candidate_2,]) + decomposed_part
 82 
 83     results.extend(recursive_decomposition(key, new_decomposed_left, stop_at))
 84     results.extend(recursive_decomposition(key, new_decomposed_right, stop_at))
 85 
 86     return results
{% endhighlight %}
<center>
<figcaption><i>Excerpt from qtext_cracker.py - the decomposition function</i></figcaption>
</center>
</figure>
{::options parse_block_html="false" /}

Considering a 16 byte key, that means between $$2^{16}$$ and $$2^{17}$$ branches, which isn't too bad, but luckily there are a couple of constraints that help us out in minimizing the search space.

### Reversing the first stage - 4 bytes to 4 printable characters
The first constraint is pretty straightforward - any decomposed byte was originally a passcode byte - meaning an uppercase letter or number.
{::options parse_block_html="true" /}
<div style="overflow-x: scroll">
$$
\begin{array}{l}
\begin{align}
    &a_2 = \color{red}{0xb0} \tag{case 1} \\
    &a_2 = \color{green}{0x30} \tag{case 2}
\end{align}
\end{array}
$$
</div>
{::options parse_block_html="false" /}

Considering the above case - it's clear we could have only chosen the second case, which happens to be the correct one.

### Reversing the second stage - 16 bytes to $$4\times4$$ byte string
The second constraint isn't as trivial, but also fairly simple - the format of the 16 byte key before the second permutation is a sequence of 4 bytes repeating 4 times.
That means we only have to decompose a 4 byte suffix - and then re-feed 4 byte suffix through the permutation function and check if we have the original key.

That narrows our search space down to $$2^5$$ for each step - or $$2^6$$ in total.


## Putting it all together
So - starting from the 16 byte key ($$K$$) as extracted from the document:
1. Run $$K$$ through the decomposition function, accumulating all possible 4 suffixes.
2. Feed suffixes back through permutation function to find the correct one.
3. Run resulting suffix through the decomposition function, again accumulating all results.
4. Narrow results down to those matching the passcode input space to arrive at the original passcode.


TODO - screenshot of script running on document

The qtext cracker script in its entirety can found [here][qtext-cracker].


[pkzip-wiki]: https://en.wikipedia.org/wiki/PKZIP
[dosbox]: https://www.dosbox.com/
[scummvm]: https://www.scummvm.org/
[exetools]: https://www.exetools.com/
[dos4gw]: https://dos4gw.org/3F_-_Overlay_manager_interrupt_Microsoft_LINK_EXE_Borland_TLINK_VROOMM
[ssowkolow]: http://blog.ssokolow.com/archives/2018/12/02/resources-for-reverse-engineering-16-bit-applications/
[cfg-wiki]: https://en.wikipedia.org/wiki/Control-flow_integrity
[qtext-cracker]: https://github.com/pipornithology/qtext
